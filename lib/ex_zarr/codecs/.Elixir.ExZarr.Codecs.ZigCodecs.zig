// this code is autogenerated, do not check it into to your code repository

// ref lib/ex_zarr/codecs/zig_codecs.ex:15
const std = @import("std");
const beam = @import("beam");
const e = @import("erl_nif");

// ZLIB Compression
pub fn zlib_compress(env: beam.env, data: []const u8) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Estimate compressed size (worst case: slightly larger than input)
    const max_size = std.compress.zlib.compressBound(data.len);
    var compressed = try allocator.alloc(u8, max_size);

    var stream = std.io.fixedBufferStream(compressed);
    var compressor = try std.compress.zlib.compressor(stream.writer(), .{});

    try compressor.writer().writeAll(data);
    try compressor.finish();

    const compressed_len = stream.pos;
    const result = try beam.make_slice(env, compressed[0..compressed_len]);

    allocator.free(compressed);
    return result;
}

// ZLIB Decompression
pub fn zlib_decompress(env: beam.env, data: []const u8) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var input_stream = std.io.fixedBufferStream(data);
    var decompressor = try std.compress.zlib.decompressor(input_stream.reader());

    // Read all decompressed data
    const decompressed = try decompressor.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(decompressed);

    return try beam.make_slice(env, decompressed);
}

// ZSTD Compression (using a simpler fallback compression for now)
pub fn zstd_compress(env: beam.env, data: []const u8, level: i32) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // For now, use deflate as a placeholder
    // TODO: Add proper zstd support via C library binding
    _ = level; // Ignore level for now

    const max_size = data.len + (data.len / 10) + 12;
    var compressed = try allocator.alloc(u8, max_size);
    defer allocator.free(compressed);

    var stream = std.io.fixedBufferStream(compressed);
    var compressor = try std.compress.deflate.compressor(stream.writer(), .{});

    try compressor.writer().writeAll(data);
    try compressor.finish();

    const compressed_len = stream.pos;
    return try beam.make_slice(env, compressed[0..compressed_len]);
}

// ZSTD Decompression
pub fn zstd_decompress(env: beam.env, data: []const u8) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // For now, use deflate as a placeholder
    // TODO: Add proper zstd support via C library binding
    var input_stream = std.io.fixedBufferStream(data);
    var decompressor = try std.compress.deflate.decompressor(input_stream.reader());

    const decompressed = try decompressor.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(decompressed);

    return try beam.make_slice(env, decompressed);
}

// LZ4 Compression (simplified implementation)
pub fn lz4_compress(env: beam.env, data: []const u8) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Using deflate as fallback
    // TODO: Implement proper LZ4 or use C library binding
    const max_size = data.len + (data.len / 10) + 12;
    var compressed = try allocator.alloc(u8, max_size);
    defer allocator.free(compressed);

    var stream = std.io.fixedBufferStream(compressed);
    var compressor = try std.compress.deflate.compressor(stream.writer(), .{});

    try compressor.writer().writeAll(data);
    try compressor.finish();

    const compressed_len = stream.pos;
    return try beam.make_slice(env, compressed[0..compressed_len]);
}

// LZ4 Decompression
pub fn lz4_decompress(env: beam.env, data: []const u8) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Using deflate as fallback
    // TODO: Implement proper LZ4 or use C library binding
    var input_stream = std.io.fixedBufferStream(data);
    var decompressor = try std.compress.deflate.decompressor(input_stream.reader());

    const decompressed = try decompressor.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(decompressed);

    return try beam.make_slice(env, decompressed);
}
