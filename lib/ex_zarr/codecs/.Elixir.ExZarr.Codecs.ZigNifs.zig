// this code is autogenerated, do not check it into to your code repository

// ref lib/ex_zarr/codecs/zig_nifs.ex:11
const std = @import("std");
const beam = @import("beam");

/// Compresses data using flate (deflate) algorithm from Zig standard library
pub fn flate_compress(data: []const u8) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Estimate maximum compressed size
    const max_size = data.len + (data.len / 10) + 32;
    const compressed_buffer = try allocator.alloc(u8, max_size);
    defer allocator.free(compressed_buffer);

    var fbs = std.io.fixedBufferStream(compressed_buffer);
    var compressor = std.compress.flate.compressor(fbs.writer(), .{});

    _ = try compressor.write(data);
    try compressor.close();

    const compressed_len = fbs.pos;

    // Allocate result that BEAM will own
    const result = try beam.allocator.alloc(u8, compressed_len);
    @memcpy(result, compressed_buffer[0..compressed_len]);

    return result;
}

/// Decompresses flate-compressed data
pub fn flate_decompress(data: []const u8) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var fbs = std.io.fixedBufferStream(data);
    var decompressor = std.compress.flate.decompressor(fbs.reader());

    const decompressed = try decompressor.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(decompressed);

    // Copy to BEAM-managed memory
    const result = try beam.allocator.alloc(u8, decompressed.len);
    @memcpy(result, decompressed);

    return result;
}

/// Compresses data using ZSTD algorithm
pub fn zstd_compress(data: []const u8, level: i32) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const max_size = std.compress.zstd.compressBound(data.len);
    const compressed_buffer = try allocator.alloc(u8, max_size);
    defer allocator.free(compressed_buffer);

    var fbs = std.io.fixedBufferStream(compressed_buffer);
    var compressor = std.compress.zstd.compressor(fbs.writer(), .{
        .level = @intCast(level),
    });

    _ = try compressor.write(data);
    try compressor.finish();

    const compressed_len = fbs.pos;

    const result = try beam.allocator.alloc(u8, compressed_len);
    @memcpy(result, compressed_buffer[0..compressed_len]);

    return result;
}

/// Decompresses ZSTD-compressed data
pub fn zstd_decompress(data: []const u8) ![]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var fbs = std.io.fixedBufferStream(data);
    var decompressor = std.compress.zstd.decompressor(fbs.reader(), .{});

    const decompressed = try decompressor.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(decompressed);

    const result = try beam.allocator.alloc(u8, decompressed.len);
    @memcpy(result, decompressed);

    return result;
}
